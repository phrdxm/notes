### 190228

* 优先提供静态工厂方法，而不是构造器；优先使用静态工厂方法，而不是构造器。
* 尽早检测出程序中的错误。
* 单例模式的最佳写法是使用单个元素的枚举类型。
* 对象尽量不可变。完全不可变的对象一定可重用。不可变域必须用final修饰。
* 工具类要确保不可实例化。
* 在子类对象中引用父类对象很容易，super关键字就行了；在父类代码中引用子类对象，应使用模拟的self类型。
* 给定的对象去适配给定接口，只需要一个适配器对象，不要创建多个。
* 永远不要重写finalize()方法。
* 优先考虑组合，而不是继承。
* 涉及到正则表达式只能用`Pattern.compile(..)`且Pattern对象一定要复用。
* 永远不要`new String("xxx")`。
* 不要搞延迟初始化，性能提升不明显，且实现起来很复杂。
* 不要搞对象池，除非是重量级对象（数据库连接那种）。
* 对于AutoCloseable对象，必须要用try-with-resources关闭。try-with-resources不仅仅是try-catch-finally的语法糖，还压制（suppressed）了finally块中的异常，可通过真正的异常对象的getSuppressed()方法获得。

* 关于重写equals方法：
  * 五大约定：自反性、对称性、传递性、一致性和非空性。
  * 套路：
    1. `==`检查是否是同一对象。
    1. `instanceof`检查参数的类型是否是当前类型。
    1. 参数类型强转。
    1. 关键域比较：

       * float和double用`Float.compare(float, float)`和`Double.compare(double, double)`比较。
       * 其他基本类型域用`==`。
       * 对象引用域用`Objects.equals(Object, Object)`。
       * 数组域用Arrays.equals比较数组中的每个元素。
  * equals除非万不得已，不要重写。重写的类也不要有子类和父类，因为对称性和传递性牵扯到继承就会很麻烦。可以用组合代替继承。不要在不同类型的对象之间建立等价关系。