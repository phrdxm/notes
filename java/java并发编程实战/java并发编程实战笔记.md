### 第一章

#### 线程带来的问题

* 安全性问题：多个线程对一个共享变量进行操作，没有协同。典型的，多个线程同时对同一变量做自增操作。
* 活跃性问题：这个问题单线程环境下也会有，比如出现死循环，导致后面的代码无法执行。在多线程环境下会有其他活跃性问题，比如线程A等待线程B释放资源，但是B永远不释放资源，A就会永远等待；再比如喜闻乐见的死锁问题等等都是活跃性问题。
* 性能问题：线程切换调度的开销、线程协同时的同步机制抑制某些编译器优化等。

#### 框架带来的线程安全问题

* Timer类：作用是使一个任务在一定时间后执行，或周期性执行。这些任务（TimerTask）将在Timer管理的线程中执行，不由应用程序管理。所以TimerTask应以线程安全的方式访问共享数据。
* Servlet：可能出现多个请求（也就是多个线程）同时调用一个Servlet的情况。所以Servlet本身要是线程安全的，且Servlet要以线程安全的方式访问和其他Servlet共享的对象，比如会话中的对象。
* 远程方法调用（RMI）：RMI对象可能会在多个线程中被调用，且这些线程不由应用程序管理，所以要求RMI对象本身是线程安全的。远程对象可能会同时收到多个远程调用请求，所以远程对象也要是线程安全的。

### 第二章

* 需要考虑线程同步的情况：某个对象的状态是共享的且是可变的。
* 具有良好的封装性和不变性的类更容易设计为线程安全类。
* 对于并发应用程序，优先保证代码的正确性，再考虑性能。

#### 线程安全性

* 定义：当多个线程访问某个类时，不管这些线程如何交替执行，且主调代码中不需要任何额外的同步，这个类都能有正确的行为，那么这个类是线程安全的。
* 线程安全类中封装了必要的同步机制，因此客户端不需要额外的同步措施。
* 无状态的对象一定是线程安全的。

#### 原子性

* 竞态条件：基于一种可能失效的观察结果来决定下一步行动。
* 竞态条件的几种典型情况：
  * 读取-修改-写回
  * 先检查后执行
* 要避免竞态条件就要将构成竞态条件的一系列操作作为一个原子操作进行。
* 如果一个对象只有一个状态，且该状态由一个线程安全对象管理，则该对象是线程安全的。所以应尽可能使用现有的线程安全对象来管理类的状态。

#### 加锁机制

* 若一个对象内部有一组关联的状态（可互相约束），只要涉及到其中一个状态的更新，就要在一个原子操作中更新所有与之关联的状态。获取两个以上关联的状态也要在一个原子操作中进行。
* 内置锁（监视锁）：synchronized代码块用到的锁，可以是任意java对象。内置锁是一种互斥锁，这种锁有一个严重问题，就是并发性能非常差。
* 内置锁是可重入的，也就是说如果一个线程尝试获得一个自己已经持有的锁，一定会成功。重入的一种实现方式是为每个锁关联一个计数值和所有者线程。当计数值为0，认为该锁没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者并将计数值置为1。如果同一个线程再次获取该锁，计数值递增。线程退出同步代码块，计数器递减。计数值为0时，锁将被释放。

#### 用锁来保护状态

* 对于共享且可变的状态，无论何时何地访问它，都必须要持有**同一个锁**，这个锁称为该状态的保护锁。对于一组关联的状态，它们的保护锁必须是同一个。

#### 活跃性与性能

* 同步代码块不宜过长和过短，过长将影响并发性能。将一段同步代码块分解得过细将导致频繁获取锁释放锁，会影响性能和代码的简单性。
* 计算密集型的操作和可能会阻塞的操作不要放在同步代码块中。持有锁的时间过长将导致活跃性与性能问题。

### 第三章

#### 可见性

* 失效数据：在缺乏同步的程序中，一个线程对共享变量的写入操作对另一个线程可能不是立即可见的，读线程读到的数据不是最新版本，或者说是失效的。
* 线程读到的数据虽然说可能是失效的，但至少可以保证是之前的某个旧版本的数据，这种保证称为最低安全性。
* 最低安全性适用于绝大多数类型的变量，但非volatile类型的64位数值类型（long和double）例外，因为long的double的读取和写入操作不是原子操作，而是分解为两次32位操作。
* 线程A执行完某个同步代码块后，线程B进入由同一个锁保护的同步代码块，保证可以看到线程A之前的操作产生的结果。**内置锁不仅有互斥性保证，还有可见性保证**。
* volatile变量的读和写操作可以近似地看做同步的getter和setter方法，也可以将volatile关键字理解为一种比synchronized关键字更轻量级的同步机制。
* 线程A写入volatile变量随后线程B读取该变量，那么A写入之前对A可见的所有变量，在B读取后也对B可见。
* volatile变量的一种典型用法：作为某个操作完成、中断或其他状态的标志。
* synchronized既可以确保原子性也可以确保可见性，volatile变量只能确保可见性。
* volatile状态不应该与其他状态关联，不应该在同步代码块中访问。

#### 发布与逸出

* 发布：对象作用域之外的代码可以获取该对象的引用，称该对象是已发布的。
* 对象发布的几种方式：
  * 将对象直接公开。
  * 将对象共享给其他线程。
  * 将对象传递给外部方法或可重写方法。
  * 对象A依赖于对象B，A被发布导致B被连带发布。
* 逸出：某个不该发布的对象被发布时，称为逸出。逸出的对象有被误用的风险。
* this引用逸出：在构造器中发布this对象，这种现象称为不正确构造。
* this引用逸出的几种典型情况：
  * 在构造器中创建内部类对象并发布。
  * 在构造器中启动线程。
  * 在构造器中调用可重写的实例方法，相当于将this对象传递给一个不可控的方法。