### 第一章

#### 线程带来的问题

* 安全性问题：多个线程对一个共享变量进行操作，没有协同。典型的，多个线程同时对同一变量做自增操作。
* 活跃性问题：这个问题单线程环境下也会有，比如出现死循环，导致后面的代码无法执行。在多线程环境下会有其他活跃性问题，比如线程A等待线程B释放资源，但是B永远不释放资源，A就会永远等待；再比如喜闻乐见的死锁问题等等都是活跃性问题。
* 性能问题：线程切换调度的开销、线程协同时的同步机制抑制某些编译器优化等。

#### 框架带来的线程安全问题

* Timer类：作用是使一个任务在一定时间后执行，或周期性执行。这些任务（TimerTask）将在Timer管理的线程中执行，不由应用程序管理。所以TimerTask应以线程安全的方式访问共享数据。
* Servlet：可能出现多个请求（也就是多个线程）同时调用一个Servlet的情况。所以Servlet本身要是线程安全的，且Servlet要以线程安全的方式访问和其他Servlet共享的对象，比如会话中的对象。
* 远程方法调用（RMI）：RMI对象可能会在多个线程中被调用，且这些线程不由应用程序管理，所以要求RMI对象本身是线程安全的。远程对象可能会同时收到多个远程调用请求，所以远程对象也要是线程安全的。

### 第二章

* 需要考虑线程同步的情况：某个对象的状态是共享的且是可变的。
* 具有良好的封装性和不变性的类更容易设计为线程安全类。
* 对于并发应用程序，优先保证代码的正确性，再考虑性能。

#### 线程安全性

* 定义：当多个线程访问某个类时，不管这些线程如何交替执行，且主调代码中不需要任何额外的同步，这个类都能有正确的行为，那么这个类是线程安全的。
* 线程安全类中封装了必要的同步机制，因此客户端不需要额外的同步措施。
* 无状态的对象一定是线程安全的。

#### 原子性

* 竞态条件：基于一种可能失效的观察结果来决定下一步行动。
* 竞态条件的几种典型情况：
  * 读取-修改-写回
  * 先检查后执行
* 要避免竞态条件就要将构成竞态条件的一系列操作作为一个原子操作进行。
* 如果一个对象只有一个状态，且该状态由一个线程安全对象管理，则该对象是线程安全的。所以应尽可能使用现有的线程安全对象来管理类的状态。

#### 加锁机制

* 若一个对象内部有一组关联的状态（可互相约束），只要涉及到其中一个状态的更新，就要在一个原子操作中更新所有与之关联的状态。获取两个以上关联的状态也要在一个原子操作中进行。
* 内置锁（监视锁）：synchronized代码块用到的锁，可以是任意java对象。内置锁是一种互斥锁，这种锁有一个严重问题，就是并发性能非常差。
* 内置锁是可重入的，也就是说如果一个线程尝试获得一个自己已经持有的锁，一定会成功。重入的一种实现方式是为每个锁关联一个计数值和所有者线程。当计数值为0，认为该锁没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者并将计数值置为1。如果同一个线程再次获取该锁，计数值递增。线程退出同步代码块，计数器递减。计数值为0时，锁将被释放。

#### 用锁来保护状态

* 对于共享且可变的状态，无论何时何地访问它，都必须要持有**同一个锁**，这个锁称为该状态的保护锁。对于一组关联的状态，它们的保护锁必须是同一个。

#### 活跃性与性能

* 同步代码块不宜过长和过短，过长将影响并发性能。将一段同步代码块分解得过细将导致频繁获取锁释放锁，会影响性能和代码的简单性。
* 计算密集型的操作和可能会阻塞的操作不要放在同步代码块中。持有锁的时间过长将导致活跃性与性能问题。