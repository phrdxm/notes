### 190224

* Java技术体系包括以下几个部分：
  * Java编程语言
  * Java标准类库
  * 来自商业机构或开源社区的第三方类库
  * JVM
  * .class文件结构
其中，Java编程语言、Java标准类库和JVM称为JDK；Java标准类库和JVM称为JRE。

* Java程序在运行时，内存分为如下几个区域：
  * 程序计数器，当某个线程执行字节码指令时，通过计数器选取下一条指令。程序计数器是线程私有的，而且在native方法执行过程中，程序计数器是不存在的，因为程序计数器只能用于指示**字节码指令**的位置。
  * 虚拟机栈，也是线程私有的，生命周期和线程一样。它用来描述Java方法的内存模型，方法开始和结束就对应了一个栈帧在虚拟机栈中的push和pop。栈帧是方法运行期的基础数据结构，用来保存方法的出入口信息、方法中的局部变量等等，之前经常听到的“对象保存在堆，变量保存在栈”这种说法，其中的“栈”，指的就是虚拟机栈中的保存局部变量的那一部分（也就是局部变量表）。局部变量表中不仅可以保存8中基本类型的值，还可以保存reference类型和returnAddress（字节码指令地址）类型。long和double占用两个单位空间，其他类型都是占用一个单位。对于一个完全确定的Java方法，它所需要的局部变量表的大小也是确定的，所以局部变量表的大小在编译期间就能确定，而且这个大小在运行期不会变。虚拟机栈可能会出现两种异常，一个是喜闻乐见的StackOverflowError，写递归的时候容易出现。从虚拟机栈的角度来说，就是栈中放了太多的栈帧（方法层级太多了），超出了限定的最大数量；还有就是OutOfMenoryError，往栈中push栈帧的时候，如果栈太短，就要找内存扩展，如果找不到可用的内存，就出现该错误。
  * 本地方法栈，它的作用和虚拟机栈相似，只不过虚拟机栈给Java方法提供服务，而本地方法栈给native方法提供服务。不同的虚拟机对本地方法栈有不同的实现，甚至有虚拟机将两个栈合二为一。
  * 堆，最大也是最重要的一块区域，被所有线程共享，虚拟机启动时创建，作用是保存对象实例和数组，GC管的也正是这一块区域。从GC角度看，堆还可以细分（怎么分以后会学到）。从内存分配的角度看，堆中会分出一部分空间给线程私有，也就是线程私有的分配缓冲区了。堆可以在物理上不连续，跟链表一样，逻辑上连续即可，堆的大小在运行期是可变的，如果堆爆满需要扩展，但又找不到可用的内存扩展，就会出OutOfMemoryError错误。